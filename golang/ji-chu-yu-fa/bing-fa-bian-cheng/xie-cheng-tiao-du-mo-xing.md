# 协程调度模型



### 一 go通信主张

数据放在共享内存中提供给多个线程访问的方式，虽然思想上简单，但却有两个问题：

* 使并发访问控制变得复杂
* 一些同步方法的使用会让多核CPU的优势难以发挥

Go的著名主张：

> 不要用共享内存的方式来通信，应该以通信作为手段来共享内存

Go推荐使用通道（channel）的方式解决数据传递问题，在多个goroutine之间，channel复杂传递数据，还能保证整个过程的并发安全性。

当然Go也依然提供了传统的同步方法，如互斥量，条件变量等。

### 二 Go线程模型

**2.0 线程模型三元素**

Go的线程实现模型有三个元素，即MPG：

* M：machine，一个M代表一个工作线程
* P：processor，一个P代表执行一个Go代码段需要的上下文环境
* G：goroutine，一个G代表一个Go协程

每个G的执行需要P和M的支持，M与P关联后才会形成一个有效的G运行环境，即 `工作线程+上下文环境`。

内核调度实体（KSE）负责调度这些工作线程M，每个实体对应一个M，如图所示：

[![](https://github.com/overnote/over-golang/raw/master/images/go/02-05.svg)](https://github.com/overnote/over-golang/blob/master/images/go/02-05.svg)

**3.1 M**

工作线程M用来关联上下文环境P。

创建新的工作线程M时机：

* 没有足够的工作线程
* 一些特殊情况下，如：执行系统监控，执行垃圾回收等

M常用源码字段如下：

```text
type m struct {
    g0 *g                   // Go运行时启动之初创建，用于执行运行时任务
    mstartfn func()         // M起始函数，即代码中 go 携带的函数
    curg *g                 // 存储当前正在运行的代码段G的指针
    p puintptr              // 指针：当前关联的上下文P
    nextp puintptr          // 指针：与当前M有潜在关联的P，调度器将某个P赋给某个M的nextp，则及时预关联
    spinning bool           // 当前M是否正在寻找可运行的G
    lockedg *g              // 与当前M锁定的G
}
```

M的生命：

* 创建：
  * M被创建后，就会加入全局M列表（runtime.allm\)，并设定M的 mstartfn、p （起始函数、上下文环境）
  * 然后，运行时为M创建一个新工作线程并与之关联
  * 起始函数只作为系统监控和垃圾回收使用（通过起始函数可以获取M所有信息，也可以防止M被当做垃圾回收掉）。
* 停止：
  * 运行时停止M时，M会被放入空闲M列表（runtime.sched.midle\)
  * 运行时从该列表中回收M

Go可以手动设定可以使用的M数量：

```text
runtime/debug.SetMaxThreads
```

一个Go程序默认最多可使用10000个M，该值越早设定越好。

**3.2 P**

goroutine（即G）如果需要运行，需要获得运行时机。当Go运行时让上下文环境P与工作线程M建立连接后，P中的G就可以运行。

P的结构包含两个重要成员：

* 可运行G队列：要运行的G列表
* 自由G列表：已完成运行的G列表，可以提高G的复用率

贴士：

> P的数量即是G的队列数量，其最大值用来限制并发运行G的规模，可以在`runtime.GOMAXPROCS`中设置。

P的重复利用：

* 连接：Go运行时让P与M连接后，P中的G开始运行
* 分离：G进入系统调用后，运行时会将M和对应的P分离
  * 如果P的可运行队列中还有未被运行的G，运行时会找到一个空闲的M或者创建新的M，并与该P关联，以满足剩余的G运行需要，所以一般情况下M的数量都会比P多。
* 空闲：P与M分离后，会被放入空闲P列表\(runtime.sched.pidle\)
  * 此时会清空P中的可运行G队列，如果运行时需要一个空闲的P与M关联，则从该列表取出一个

P的生命，如图：

[![](https://github.com/overnote/over-golang/raw/master/images/go/02-06.svg)](https://github.com/overnote/over-golang/blob/master/images/go/02-06.svg)

贴士：

* 非Pdead状态的P都会在运行时要停止调度时被设置为Pgcstop状态，等到要重新调度时，不会被恢复到原有状态，而是统一被转换为Pidle状态，公平接受再次调度。
* 自由G列表会随着完成运行的G增多而增大，到一定程度后，运行时会将其中部分G转移到调度器自己的自由G列表中。

**3.3 G**

一个G代表一个Go协程goroutine，即go函数。

在go函数启动一个G时：

* 运行时会先从相应的P的自由G列表获取一个G封装go函数
* 如果P的自由G列表为空，则会从调度器本身的自由G列表中转移过来一些G到P的自由G列表中
* 如果调度器本身的自由G列表也为空，则新建一个G

运行时本身持有一个G的全局列表（runtime.allgs\)，用于存放当前运行时系统中所有G的指针，新建的G会被加入该列表。

执行步骤：

* 初始化：无论是新G还是取出来的G都会被运行时初始化，包括其关联函数、G状态、ID
* 将初始化后的G存储到本地P的runnext字段中
* 如果runnext字段中已经存在G，则存在的G会被踢到该P可运行G队列的末尾，如果队列已满，则G只能追加到调度器本身的可运行G队列中

每个G都会由运行时根据需要设置为不同的状态：

* Gidle：刚被分配，未初始化
* Grunnabel：正在可运行队列中等待运行
* Grunning：正在运行
* Gsyscall：正在执行某个系统调用
* Gwaiting：G被阻塞中
* Gdead：G闲置中
* Gcopystack：G的栈因为扩展或收缩，正在被移动

G还有一些组合状态Gscan，组合态代表G的栈正在被GC扫描，如：

* Gscanrunnable：G等待运行中，它的栈也被正在扫描（因为垃圾回收）
* Gscanrunning：G运行中，它的栈正在被GC扫描

G的状态转换图：  
[![](https://github.com/overnote/over-golang/raw/master/images/go/02-07.svg)](https://github.com/overnote/over-golang/blob/master/images/go/02-07.svg)

注意：

* 进入死亡状态Gdead的G可以重新被初始化
* 但是P进入死亡状态Pdead后只能被销毁

### 四 MPG容器

MPG常见容器：

| 名称 | 源码 | 作用域 | 说明 |
| :--- | :--- | :--- | :--- |
| 全局M列表 | runtime.allm | 运行时 | 存放所有M的单向链表 |
| 全局P列表 | runtime.allp | 运行时 | 存放所有P的数组 |
| 全局G列表 | runtime.allgs | 运行时 | 存放所有G的切片 |
| 空闲M列表 | runtime.sched.midle | 调度器 | 存放空闲M的单向链表 |
| 空闲P列表 | runtime.sched.pidle | 调度器 | 存放空闲P的单向链表 |
| 调度器可运行G队列 | runtime.sched.runqhead runtime.sched.runqtail | 调度器 | 存放可运行的G的队列 |
| 调度器自由G列表 | runtime.sched.gfreeStack runtime.sched.gfreeNoStack | 调度器 | 存放自由G的两个单向链表 |
| P可运行G队列 | runtime.p.runq | 本地P | 存放当前P中可运行的G的队列 |
| P自由G列表 | runtime.p.gfree | 本地P | 存放当前P的自由G的单向链表 |

贴士：

* 任何G都会存在于全局G列表中，其余的4个容器则只会存放在当前作用域内的具有每个状态的G。
* 调度器的可运行G列表和P的可运行G列表拥有几乎平等的运行机会：
  * 刚被初始化的G都会被放入本地P的可运行G队列
  * 从Gsyscall状态转出的G都会被放入调度器的可运行G队列
  * Gdead状态的G，会被放入本地P的自由G列表

两个可运行G队列会互相转移G：

* 调用runtime.GOMAXPROCS函数，会导致运行时系统把将死的P的可运行G队列中的G全部转移到调度器的可运行G队列
* 如果本地P的可运行G队列已满，则一半的G会被转移到调度器可运行G队列中



### 一 调度器的调度

**1.0 调度器概述**

Go线程模型中一部分调度任务由操作系统内核之外的程序承担，即调度器。其调度对象是M、P、G的实例。

每个M在运行过程中的偶会按需执行一些调度任务。

MPG模式运行状态： [![](https://github.com/overnote/over-golang/raw/master/images/go/02-08.svg)](https://github.com/overnote/over-golang/blob/master/images/go/02-08.svg)

**1.1 一轮调度**

go程序初始化完毕后，调度器会进行一轮调度\(位于runtime中的schedule函数\)，以让main函数中的G有机会开始运行。

一轮调度查找G流程：

* 1 调度器会先查找全局（调度器的）可运行G队列以及本地P的可运行G队列
* 2 找不到则进入强力查找模式：从任何可以获得G的地方查找G
* 3 还是找不到，则该子流程暂停，直到有可运行的G出现才会继续下去
* 4 子流程结束，意味着当前M抢到了一个可运行的G

调度器找到G后的流程：

* 如果调度器在一轮调度之初发现当前M已经与某个G锁定，会立即停止调度并阻塞当前M，如果G到了可运行状态，M会被唤醒并继续运行G。
* 如果当前M找到了可运行G，却发现该G与另外的M锁定，它会唤醒绑定的M来运行该G，并重新为当前M寻找可运行G
* 如果当前M未与任何G锁定\(gcwaiting值不为0\)，那么停止Go调度器，即STW\(Stop the world\)并等待运行时串行任务正在执行
* 当锁定和运行时串行任务都为假，执行寻找G。

**1.2 强力查找模式**

一轮调度器开启强力找子流程时，会多次尝试从任何可以获得G的地方查找G，使用的函数是`runtime.findrunnabel`，返回一个处于`Grunnable`状态的G。

阶段一执行步骤如下：

* 步骤一：获取终结函数的G。对象在未被任何其他对象引用时（不可达）就会被垃圾回收器回收，回收前会调用函数`runtime.SetFinalizer`将该对象与一个中终结函数绑定。所有的终结函数由一个专用的G负责。调度器如果发现该G完成任务，会将其状态设置为Grunnable并放入本地P的可运行G队列。
* 步骤二：从本地P的可运行G队列获取一个G
* 步骤三：找不到则从调度器的可运行对垒获取G
* 步骤四：找不到则从网络I/O轮询器（netpoller）获取G
* 步骤五：找不到则从其他P的可运行G队列获取G

如果上述步骤还是无法搜索到可用G，那么搜索进入阶段二：

* 步骤一：调度器判断是否处于GC标记节点，如果是，则把本地P持有的GC标记的G状态改为Grunnable并返回结果
* 步骤二：再次从调度器可运行G队列获取G，找不到则解除本地P与当前M关联，并把P放入调度器的空闲P列表
* 步骤三：遍历全局P列表中的P，检查可运行G队列，如果发现某个P的可运行G队列不为空，则取出一个P，关联到当前M，进入阶段一重新执行
* 步骤四：全局P列表也没有可运行G队列，则判断是否正处于GC标记节点，以及相关资源是否可用，如果都是true，调度器会从空闲P列表拿出一个P，如果该P持有一个GC标记专用G，就关联P与M，执行阶段二的步骤一
* 步骤五：继续从I/O轮询器获取G

上述2个阶段都查找不到G，则调度器就会停止当前M。

**1.3 M的启动与停止**

在高并发Go程序中，并发量越大，调度器对MPG的调度就越频繁，相应的M的启动和停止也会被执行的更频繁。

M启动和停止相关的函数有：

* `stopm()`：停止当前M，直到有心的G变得可运行而被唤醒
* `gcstopm()`：停止当前M，为串行运行时任务的执行让路，任务结束后被唤醒
* `stoplockedm()`：停止与G锁定的M的执行，直到这个G变得可运行而被重新唤醒
* `startlockedm(gp *g)`：唤醒与gp锁定的M，并让M执行gp
* `startm(_p_ *p, spining bool)`：唤醒或者创建一个M，然后关联\_p\_并执行

**1.4 系统检测任务**

系统检测任务由函数`sysmon`实现，他完成了以下事情：

* 在需要时抢夺符合条件的P和G
* 在需要时进行强制GC
* 在需要时清扫堆
* 在需要时打印调度器跟踪信息

检测任务被包裹在一个循环之中，会被一直执行下去，直到Go程序结束。

### 二 g0和m0

M中拥有两个特殊的元素

* g0：M初始化时运行时生成的线程，所在的栈称为调度栈/系统栈/调度栈/OS线程栈，用于执行调度、垃圾回收、栈管理
* gsignal：处理信号的G，所在的栈称为信号栈
* runtime.g0：用于执行引导程序，位于Go程序第一个内核线程中，该内核线程是runtime.m0

注意：

* g0不会被阻塞，也不会包含在任何G队列或者列表中，其栈也不会再垃圾回收期被扫描
* runtime.m0和runtime.g0都是静态分配的，无需分配内容
* runtime.m0的g0级runtime.g0

### 三 调度器锁和原子操作

每个M都有可能执行调度任务，这些任务的执行在时间上可能会重叠，即并发的调度。因此，调度器会在读写一些全局变量以及它的字段时使用调度器锁进行保护。

Go运行时系统在一些需要保证并发安全的变量存取上使用了原子操作。原子操作比锁操作清凉很多，可以节约大量资源，比如sched.nmspinning,sched.ngsys等变量读写时都会用到原子操作。

### 四 GC调整

当前Go的GC基于CMS算法，拥有三种执行模式：

* gcBackgroundMode：并发执行垃圾收集（标记）和清扫
* gcForceMode：串行执行垃圾收集（执行时停止调度），但是会并发的执行清扫
* gcForceBlockMode：串行执行垃圾收集和清扫

调度器驱使的自动GC和系统检测任务中的强制GC，都是gcBackgroundMode模式，但是前者会检查内存使用量，只有增量过大时才执行GC，后者无视这个条件。

通过环境变量GODEBUG可以手动控制GC并发性，设置gcstoptheworld的值为1，GC的执行模式就会由gcBackgroundMode变为gcForceMode，设为2则变为gcForceBlockMode。

Go运行时系统会在分配新内存是会检查Go程序的内存使用增量，若增量翻倍，则会触发GC。人工设置`runtime/debug.SetGCPercent`函数可以改变增量阈值（int类型，已分配内存的百分之几触发GC）。默认阈值是100，为负数时不会触发GC，该函数在被调用后会返回旧的阈值。

注意：

* GOGC环境变量也可以设置GC阈值，但是必须在程序启动前进行设置
* 关闭GC后就需要手动GC，`runtime.GC`函数可以手动触发一次GC，不过这个GC函数会阻塞调用方直到GC完成，此时GC以gcForceBlockMode模式执行
* 调用`runtime/debug`包的`FreeOSMemory`函数也可以手动触发一次串行GC，并在GC完成后执行一次清扫堆操作


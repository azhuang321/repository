# 概述

### 一 顺序表概述

线性表只是一种逻辑结构，在物理上它的存储可以是顺序的也可以是链式的。

顺序表：

> 用一段地址连续的存储单元依次存储线性表的数据元素。

如图所示：

![](https://github.com/overnote/over-algorithm/raw/master/images/structure/list-01.svg)

从上图可以看出，加入一个线性表占据了c个存储单元，那么第i个元素的存储位置为：

LOC\(ai\) = LOC\(a1\) + \(i - 1\) \* c

通过上述公式，可以随时计算出顺序表中任意位置的地址，不管是最后一个还是第一个，都是相同的时间。

顺序表的每一个数据元素的存储位置都和线性表起始位置相差一个和数据元素在线性表中的位序成正比的常熟。即只要确定了存储顺序表的起始位置，顺序表内人一个数据元素都可以随机存取，我们称这个中结构为随机存储结构。

### 二 顺序表的存取

插入：  


![](https://github.com/overnote/over-algorithm/raw/master/images/structure/list-02.png)

删除：  


![](https://github.com/overnote/over-algorithm/raw/master/images/structure/list-03.png)

如果元素插入到最后一个位置，或者删除最后一个位置，那么之前的数据元素无需排序，此时是最好的情况，时间复杂度为O\(1\)，因为不需要移动元素。如果是其他情况，则所有的数据元素都要进行移动，这个时间复杂度为O\(n\)。

### 三 总结

顺序表的底层由数组实现，顺序表逻辑关系上的相邻元素在物理位置上也相邻，这让顺序白可以随机存取表中任一元素，但是在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再要加入新的元素就会非常困难。在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后移动。

顺序表特性：

* 顺序表在修改、读入数据元素时，时间复杂度是O\(1\)，因为是一段连续的内存，直接可以通过索引获得。贴士：修改读入也即存取
* 顺序表在插入、删除数据元素时，时间复杂度是O\(n\)，因为需要重新移动位置
* 两个顺序表的合并（union），其时间复杂度应该是O\(L1.length + L2.length\)

### 四 顺序表实现的抽象数据类型

在高级语言中，数组也具备随机存储的特性，因此通常使用数组来描述数据结构中的顺序存储结构，这里定义顺序表对象名为：SqList。


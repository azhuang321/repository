# 算法概述

### 一 算法概念

算法（algorithm）是对特定问题求解步骤的一种描述，**在计算机中是指令的有限序列**，具备以下5个基本特性：

* **输入**：可以理解为参数，所以算法可以没有输入，也可以有多个输入
* **输出**：算法必须有输出，没有输出，算法也就失去了意义。但是算法也可以有0个输入，表示算法本身确定了初识条件
* **有穷性**：算法运算完毕后必须结束，其步骤必须是有限的
* **确定性**：算法的每个步骤都有明确的意义，在一定条件下，相同的输入只能有唯一结果
* **可行性**：算法的每一步都必须是可行有效的，即每一步都能通过执行有限次数完成

一个算法如果要设计好，必须达到以下目标：

* 正确性（correctness）：不含语法错误，对各种需求的输入数据都能满足
* 可读性（readability）：算法程序应该简洁易懂
* 鲁棒性（robustness）：非法数据被输入时，不会引起算法崩溃、出错，即健壮性
* 效率与低存储量需求：算法要尽量优秀，即：执行时间短，占据内存小！

**算法的原地工作**：

```text
一个可执行程序除了需要内存空间外，如果还需要额外的空间，若该额外空间相对于问题的规模来说是个常数，那么称之为原地工作！ 
```

### 二 算法复杂度

#### 2.1 算法的执行次数

程序的执行时间是无法准确预估的，可以通过预估代码基本操作的执行次数来判断算法的效率。

规模为n的问题，所需要的时间可以记为 `T(n)`，即在代码中，语句的总执行次数使用T\(n\)表示：

```text
T(n)= O(f(n)) 
```

如下示例中，算法的执行规模是n，执行次数是：`T(n) = 3n + 1`。

```text
func fn1(n int){
    for i := 0; i < n; i++ {
        fmt.Println("开始输出")             // 这里执行 1 * n 次
        fmt.Println(i)                  // 这里执行 1 * n 次
        fmt.Println("结束输出")         // 这里执行 1 * n 次
    }
    fmt.Println("跳出循环")             // 这里执行1次
}
```

通过计算算法中代码的基本执行次数可以粗略的估算算法的效率。

#### 2.2 函数的渐进增长

现在实现一个结果有两个算法：算法A与算法B，他们的输入规模都是n，算法A要做2n+3次操作，算法B要做3n+1次操作，两个算法谁更快？

一开始A算法计算次数很多，但是随着n的增长\(大于2\)，A算法计算次数比算法B越来越少，所以算法A整体上比算法B好。

输入规模 n 在没有限制的情况下，只要超过一个数值 N ，这个函数就总大于另一个函数，则称函数是**渐进增长**：

> 函数的渐进增长：给定两个函数 f\(n\) 和 g\(n\)，如果存在一个整数 N，使得所有的 n&gt;N ,f\(n\) 总是比 g\(n\) 大，那么 f\(n\) 的增长渐进快于 g\(n\)。

在评价算法的效率时，往往忽略其处理小规模问题的差异，而是关注在更大规模问题时的表现，即更注重随着规模的增大，其效率的总体变化趋势。

#### 2.2 算法的时间复杂度

> 时间复杂度：随着问题规模 n 的增长，算法执行时间的增长率和f\(n\)的增长率相同，称为算法的渐进时间复杂度，简称**时间复杂度**。

这样用O\(\)来体现算法时间复杂度的记法，也称为**大O表示法（big-O notation）**。一般情况下，T\(n\)增长最慢的算法为最优算法。程序中语句的重复执行的次数称为**频度**（frequency count），频度直接影响了算法的时间复杂度。

**最坏情况与平均情况**：  
比如查询n个随机数数组中最小数，最好第一个元素就是，那么时间复杂度为O\(1\)，如果很不幸数组的最后一个元素才是，那么时间复杂度是O\(n\)。

所以算法的时间复杂度具体会受到2个因素影响：

* 问题的规模：规模（n）越大，算法的基本操作执行的次数越多
* 待处理数据的初态：如两个数相称，如果有一个因子为0，那么算法的时间复杂度立刻就变为了O\(1\)

对算法的分析有两种方法：

* 计算所有情况的平均值，称为平均时间复杂度\(上述案例的n/2\)
* 计算最坏情况下的复杂度，**一般都会使用最坏复杂度**

#### 2.3 算法的空间复杂度

通过空间能够换取时间上的便利，比如判断某个年份是否是闰年，我们可以书写一个算法，这个算法每次给出年份都要进行计算，但是我们也可以将所有的年份书写为一个键值对，是闰年的值为1，不是的值为0，这样判断是否是闰年直接查看键值对结果即可，但是相应的，我们需要这个键值对的额外存储空间。

算法的空间复杂度（space complexity）公式：

```text
S(n) = O(f(n))      # n为问题规模，f(n)为n锁占存储空间的函数，同样使用大O表示法表示空间复杂度
```

贴士：如果算法执行时所需的辅助空间相遇于输入的数据量来说是个常数，那么称此算法为原地工作，空间复杂度为O\(1\)。

空间复杂度有以下几种情形：

* 常量空间 O\(1\)：存储空间固定，与输入的规模无关
* 线性空间 O\(n\)：存储空间是一个线性集合如数组，集合大小与输入规模n成正比
* 二维空间 O\(n2\)：分配的空间是一个二维数组集合，集合的长度、宽度与输入规模n成正比
* 递归空间：计算机在运行递归代码时，会专门分配一块内存，存储方法调用栈，递归越深，入栈元素越多，到达结束条件时，方法出栈。执行递归操作所需要的内存空间和递归的深度成正比，纯粹递归操作的空间复杂度也是线性的，如果递归深度是n，那么其空间复杂度就是O\(n\)

**通常我们说算法的复杂度是指时间复杂度**，因为在当前时代，对速度的追求往往大于对空间的追求。

#### 2.4 大Ω记号 与 大Θ记号

一般大O记号表示了算法的最坏复杂度，一般使用：

* 大Ω记号：表示算法的最好情况，所以T\(n\)一般介于 Ω\(g\(n\)\) 与 O\(f\(n\)\) 之间。
* 大Θ记号：表示算法恰好出现了 g\(n\) = f\(n\) 的情况

如果存在正的常数c和函数g\(n\)，对任意n&gt;&gt;2，有T\(n\) &gt; c \* g\(n\)，即认为：在n足够 大后，g\(n\)给出了T\(n\)的一个下界，记为：

```text
T(n) = Ω(g(n))
```

如果存在正的常数c1和c2，以及函数h\(n\)，对任意n&gt;&gt;2，有 c1\*h\(n\) &lt; T\(n\) &lt; c2 \* h\(n\)，即认为：在n足够大后，h\(n\)给出了T\(n\)的一个确界，记为：

```text
T(n) = Θ(g(n))
```

三者关系如图：  


![](https://github.com/overnote/over-algorithm/raw/master/images/structure/01-07.png)

